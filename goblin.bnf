_digit : '0'-'9' ;
int_lit : _digit { _digit } ;
float_lit : _digit { _digit } '.' _digit { _digit } ;

_alpha : 'a'-'z' | 'A'-'Z' | '_' ;
_alphanum : _alpha | _digit ;
id : _alpha { _alphanum } ;

_ascii_char
    : '\x01' - '\x21'
    | '\x23' - '\x5B'
    | '\x5D' - '\x7F'
;
_unicode_byte
    : '\u0080' - '\uFFFC'
    // skip invalid code point (\uFFFD)
    | '\uFFFE' - '\U0010FFFF'
;
_unicode_char
    : _ascii_char
    | _unicode_byte
;

_escaped_char : '\\' ( _unicode_char | '"' | '\\' ) ;
_char         : _unicode_char | _escaped_char ;

string_lit : '"' { _char } '"' ;
!whitespace : ' ' | '\t' | '\n' | '\r' ;
!comment : '#' {.} '\n' ;


<< import (
    "github.com/aisk/goblin/ast"
) >>


Module
    : Statements                             << ast.NewModule($0) >>
;

Statements
    : empty
    | StatementList
;

StatementList
    : Statement                              << ast.NewStatementList($0) >>
    | StatementList Statement                << ast.AppendStatementList($0, $1) >>
;

Statement
    : Expression
    | Declare
    | Assign
    | If
    | IfElse
    | While
    | For
    | Break
    | FunctionDefine
    | Return
    | Export
;

ExpressionList
    : Expression                             << ast.NewExpressionList($0) >>
    | ExpressionList Expression              << ast.AppendExpressionList($0, $1) >>
;

Expression
    : Expression1
;

Expression1
    : Expression2
    | Expression1 "&&" Expression2           << ast.NewBinaryOperation($0, "&&", $2) >>
    | Expression1 "||" Expression2           << ast.NewBinaryOperation($0, "||", $2) >>
;

Expression2
    : Expression3
    | Expression2 "==" Expression3           << ast.NewBinaryOperation($0, "==", $2) >>
    | Expression2 "!=" Expression3           << ast.NewBinaryOperation($0, "!=", $2) >>
    | Expression2 "<=" Expression3           << ast.NewBinaryOperation($0, "<=", $2) >>
    | Expression2 ">=" Expression3           << ast.NewBinaryOperation($0, ">=", $2) >>
    | Expression2 "<" Expression3            << ast.NewBinaryOperation($0, "<", $2) >>
    | Expression2 ">" Expression3            << ast.NewBinaryOperation($0, ">", $2) >>
;

Expression3
    : Expression4
    | Expression3 "+" Expression4            << ast.NewBinaryOperation($0, "+", $2) >>
    | Expression3 "-" Expression4            << ast.NewBinaryOperation($0, "-", $2) >>
;

Expression4
    : Expression5
    | Expression4 "*" Expression5            << ast.NewBinaryOperation($0, "*", $2) >>
    | Expression4 "/" Expression5            << ast.NewBinaryOperation($0, "/", $2) >>
;

Expression5
    : PostfixExpression
    | "!" Expression5                        << ast.NewUnaryOperation("!", $1) >>
;

PostfixExpression
    : PrimaryExpression
    | PostfixExpression "[" Expression "]"   << ast.NewIndexExpression($0, $2) >>
    | PostfixExpression "(" Arguments ")"    << ast.NewCallExpression($0, $2) >>
    | PostfixExpression "." id               << ast.NewMemberExpression($0, $2) >>
;

PrimaryExpression
    : IntegerLiteral
    | FloatLiteral
    | StringLiteral
    | TrueLiteral
    | FalseLiteral
    | NilLiteral
    | ListLiteral
    | DictLiteral
    | id                                     << ast.NewIdentifier($0) >>
    | "(" Expression ")"                     << $1, nil >>
;

IntegerLiteral
    : int_lit                                << ast.NewIntegerLiteral($0) >>
;

FloatLiteral
    : float_lit                              << ast.NewFloatLiteral($0) >>;

StringLiteral
    : string_lit                             << ast.NewStringLiteral($0) >>
;

TrueLiteral
    : "true"                                 << ast.NewTrueLiteral() >>
;

FalseLiteral
    : "false"                                << ast.NewFalseLiteral() >>
;

NilLiteral
    : "nil"                                  << ast.NewNilLiteral() >>
;

ListLiteral
    : "[" ListElements "]"                   << ast.NewListLiteral($1) >>
;

ListElements
    : empty
    | ListElementList
;

ListElementList
    : Expression                             << ast.NewExpressionList($0) >>
    | ListElementList "," Expression        << ast.AppendExpressionList($0, $2) >>
;

DictLiteral
    : "{" DictElements "}"                   << ast.NewDictLiteral($1) >>
;

DictElements
    : empty
    | DictElementList
;

DictElementList
    : DictElement                            << ast.NewDictElementList($0) >>
    | DictElementList "," DictElement        << ast.AppendDictElementList($0, $2) >>
;

DictElement
    : Expression ":" Expression              << ast.NewDictElement($0, $2) >>
;

Arguments
    : empty
    | ArgumentList
;

ArgumentList
    : Expression                             << ast.NewExpressionList($0) >>
    | ArgumentList "," Expression            << ast.AppendExpressionList($0, $2) >>
;

Declare
    : "var" id "=" Expression                << ast.NewDeclare($1, $3) >>
;

Assign
    : id "=" Expression                      << ast.NewAssign($0, $2) >>
;

Block
    : "{" Statements "}"                     << $1, nil >>
;

Condition
    :  Expression
;

If
    : "if" Condition Block                   << ast.NewIf($1, $2, nil) >>
;

IfElse
    : "if" Condition Block "else" Block      << ast.NewIf($1, $2, $4) >>
    | "if" Condition Block "else" If         << ast.NewIf($1, $2, $4) >>
    | "if" Condition Block "else" IfElse     << ast.NewIf($1, $2, $4) >>
;

While
    : "while" Condition Block                << ast.NewWhile($1, $2) >>
;

For
    : "for" id "in" Expression Block         << ast.NewFor($1, $3, $4) >>
;

Break
    : "break"                                << ast.NewBreak() >>
;

Parameters
    : empty
    | ParameterList
;

ParameterList
    : id                                     << ast.NewParameterList($0) >>
    | ParameterList "," id                   << ast.AppendParameterList($0, $2) >>
;

FunctionDefine
    : "func" id "(" Parameters ")" Block     << ast.NewFunctionDefine($1, $3, $5) >>
;

Return
    : "return" Expression                    << ast.NewReturn($1) >>
;

Export
    : "export" id                            << ast.NewExport($1) >>
;
